# 단어 퍼즐

[문제 링크](https://school.programmers.co.kr/learn/courses/18/lessons/1882)

## 문제 분석 및 알고리즘 설계

- 시작 인덱스와 선택한 단어 조각의 갯수를 저장해가며, 다음 str을 맞춰본다.

- 단어 조각의 수는 작은 값을 출력해야 하므로 deque를 사용해 선입선출, bfs를 혼용한 방식으로 구현했다.

- 인덱스만으로 t를 완성했는 지 제대로 알 수 없어 string을 추가하여 완성 여부를 확인한다.

---

## 해설

- 주어진 문자열이 t이고, t의 길이가 n이라 한다.

- `t[0]` 하나로만 이루어진 문자가 주어진 단어 조각에 있다면, `t[1]`부터 시작하는 문자열을 만든다.

- `t[0] + t[1]`으로 이루어진 문자가 주어진 단어 조각에 있다면, `t[2]`부터 시작하는 문자열을 만든다.

- 필요한 조각 개수의 최솟값 구하기

  - `t[0]` 하나로 이루어진 조각을 이용했을 때 최소 사용 개수는 t[1] 부터 t[n-1]까지 문자열을 만들 수 있는 퍼즐의 최소 개수 + 1

  - `t[0] + t[1]`으로 이루어진 조각을 이용했을 때 최소 사용 개수는 t[2] 부터 t[n-1]까지 문자열을 만들 수 있는 퍼즐의 최소 개수 + 1

- 주어지는 단어 조각의 길이가 최대 5이기 때문에, 5가지의 경우를 고려하고 그 경우의 최솟값을 출력한다.

---

- i번째 위치부터 n-1번째 위치까지의 문자열을 만드는 데 필요한 최소 단어조각의 개수를 dp[i]라고 하면,

  - `dp[i] = min(dp[i+1], dp[i+2], dp[i+3], dp[i+4], dp[i+5]) + 1`

  - 단, 값을 가져올 때는 해당 거리만큼을 단어 조각으로 채울 수 있어야 한다.

- 예제 풀이

  - ["app", "ap", "p", "l", "e", "ple", "pp"], "apple"

  - dp 배열은 무한으로 초기화한다.

  - idx = 4부터 0까지 거꾸로 계산해간다.

    - `t[4] = 'e'` 이고, 주어진 단어 조각에 있으므로 해당 단어를 채운다. `dp[4] = 1`이 된다.

    - `t[3] = 'l'`이고, 단어 조각 'l'을 사용한다면 `dp[3] = min(dp[3], dp[3+1] + 1)`이 된다.

      단어 조각에 'le'는 없으므로 계산하지 않는다.

    - `t[2]`에서, 'p'를 단어 조각으로 만들면 `dp[2] = min(dp[2], dp[2+1] + 1)`

      'pl'은 단어조각에 없으므로 계산하지 않는다.

      'ple'을 단어조각으로 만들면, `dp[2] = min(dp[2], dp[2+3] + 1)`이고 dp[5]의 값은 0으로 간주한다.

  - 최종적으로 dp[0]의 값이 t를 만드는 단어조각의 최솟값이 된다.
