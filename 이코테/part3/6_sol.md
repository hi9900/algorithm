# [무지의 먹방 라이브](https://school.programmers.co.kr/learn/courses/30/lessons/42891)

회전판에 먹어야 할 N개의 음식이 있다. 각 음식에는 1부터 N까지 번호가 붙어있으며, 각 음식을 섭취하는 데 일정 시간이 소요된다.

무지는 다음 방법으로 음식을 섭취한다.

- 무지는 1번 음식부터 먹기 시작하며, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로 가져다 놓는다.

- 마지막 번호의 음식을 섭취한 후에는 회전판에 의해 다시 1번 음식이 무지 앞으로 온다.

- 무지는 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고, 다음 음식을 섭취한다.

  - 다음 음식이란, 아직 남은 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식을 말한다.

- 회전판이 다음 음식을 무지 앞으로 가져오는데 걸리는 시간은 없다고 가정한다.

무지가 먹방을 시작한 지 K초 후에 방송이 잠시 중단되었다. 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는 지 알고자 한다.

각 음식을 모두 먹는 데 필요한 시간이 담긴 배열 food_times, 네트워크 장애가 발생한 시간 K초가 매개변수로 주어질 때, 몇 번 음식부터 다시 섭취하는 지 return 하도록 solution 함수를 완성하라

제한사항

- food_times 는 각 음식을 모두 먹는데 필요한 시간이 음식의 번호 순서대로 들어있는 배열이다.

- k 는 방송이 중단된 시간을 나타낸다.

- 만약 더 섭취해야 할 음식이 없다면 -1을 반환하면 된다.

정확성 테스트 제한 사항

- food_times 의 길이는 1 이상 2,000 이하이다.

- food_times 의 원소는 1 이상 1,000 이하의 자연수이다.

- k는 1 이상 2,000,000 이하의 자연수이다.

효율성 테스트 제한 사항

- food_times 의 길이는 1 이상 200,000 이하이다.

- food_times 의 원소는 1 이상 100,000,000 이하의 자연수이다.

- k는 1 이상 2 x 10^13 이하의 자연수이다.

```
입출력 예시

food_times = [3, 1, 2]
k = 5
result = 1
```

---

## 문제 분석 및 알고리즘 설계

- 음식이 원형으로 배치되어 있고, 1번 음식부터 순서대로 1초씩 먹는다.
- 음식이 다 떨어지면 건너뛴다.
- K초 후 방송이 중단 후 방송을 이어간다. → 그 순간 다음에 먹어야 하는 음식 번호를 찾아야 함.
- 음식이 다 끝났다면 `-1` 반환
- `k` 값이 최대 `2 x 10^13`까지 가능 → O(N^2)나 단순 시뮬레이션은 불가능하다.

[핵심 아이디어]

- 가장 적은 시간이 걸리는 음식부터 라운드 단위로 먹는다.

1. 최소 힙에 (소요 시간, 음식 번호)를 넣는다.
2. 가장 작은 음식 소요시간을 기준으로 "라운드 단위"로 처리한다.
    - 현재 음식 중 가장 작은 소요시간이 `time` 이면,
    이전에 먹은 양(`prev`)을 빼고, `(time - prev) * 남은 음식 개수` 만큼 총 소요시간을 계산한다.
    - k보다 작으면 통째로 다 먹어버리고, heap 에서 pop
    - k보다 크면 그 시점에서 멈춘다
3. 멈춘 시점에서 남은 음식들을 원래 번호 순으로 정렬 후, `(k - 누적소요시간) % 남은 개수` 번째 음식을 찾는다.

---

### [문제 풀이](6_sol.py)
