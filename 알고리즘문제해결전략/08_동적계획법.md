# 8. 동적 계획법(dynamic programming)

## 8.1 도입

**[중복되는 부분 문제]**

- 처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산한다.

- 이미 계산한 값을 저장해 두는 메모리의 장소를 캐시(cache)라고 부르며, 두 번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblems)라고 부른다.

> 이항 계수 계산

- 재귀 함수 이용

```python
def bino(n, r):
    if r == 0 or n == r:
        return 1

    return bino(n-1, r-1) + bino(n-1, r)
```

- 메모이제이션 이용

```python
cache = [[-1] * 30 for _ in range(30)]
def bino2(n, r):
    if r == 0 or n == r:
        return 1
    if cache[n][r] != -1:
        return cache[n][r]
    return cache[n][r] = bino2(n-1, r-1) + bino2(n-1, r)
```

---

**메모이제이션을 적용할 수 있는 경우**

- 참조적 투명 함수의 경우에만 적용할 수 있다.

> 참조적 투명성(referential transparency): 함수의 반환 값이 그 입력 값만으로 결정되는지의 여부
>
> 참조적 투명 함수: 입력이 고정되어 있을 때 그 결과가 항상 같은 함수

**메모이제이션 구현 패턴**

- 항상 기저 사례를 제일 먼저 처리한다. 입력이 범위를 벗어난 경우 등을 기저 사례로 처리하면 유용하다.

- 함수의 반환 값이 항상 0 이상이라는 점을 이용해 `cache[]`를 모두 -1로 초기화한다. 만약, 함수의 반환 값이 음수일 수 있다면 다른 방법을 사용해야 한다.

**메모이제이션의 시간 복잡도 분석**

`존재하는 부분 문제의 수 X 한 부분 문제를 풀 때 필요한 반복문의 수행 횟수`

### 동적 계획법 레시피

1. 주어진 문제를 완전 탐색을 이용해 해결한다.

2. 중복된 부분 문제를 한 번만 계산하도록 메모이제이션을 적용한다.

---

## 예제: 외발뛰기(ID: JUMPGAME)

[풀이 코드](./ex8-1.py)

### 문제 접근

1. 재귀 호출에서 시작하기

   - jump(y, x) = (y, x)에서부터 맨 마지막 칸까지 도달할 수 있는 지 여부를 반환한다.

   - `jump(y, x) = jump(y + jumpSize, x) || jump(y, x + jumpSize)`

2. 메모이제이션 적용하기

   - 완전 탐색이 만드는 경로의 수는 엄청나게 많지만, jump()에 주어지는 입력의 개수는 `100x100`개 뿐이다.

   - `jump()`는 참조적 투명 함수이기 때문에 메모이제이션을 적용해 중복된 연산을 없앨 수 있다.

---

## 8.2 문제: 와일드카드(ID: WILDCARD)

[풀이 코드](./ex8-2.py)

### 문제 접근

- `*` 대응하기

  - 주어진 패턴이 m개의 `*`를 포함한다고 하자. 이 패턴을 `*`가 나타날 때마다 쪼개면 m+1개의 조각으로 나눌 수 있다.

  - 주어진 문자열 중 몇 글자가 첫 번째 조각에 대응될 지를 찾아낸다.

- 와일드카드 w가 문자열 s에 대응되는 지 여부를 반환하는 함수 `match(w, s)`

  - w와 s를 앞에서부터 한 글자씩 대응해나가며, `*`을 만나거나 둘 중 한 문자열이 끝날 때 멈춘다.

  ```python
  def match(w, s):
      idx = 0
      while idx < len(s) and idx < len(w) and (w[idx] == '?' or w[idx] == s[idx]):
          idx += 1
  ```

- while문을 종료하는 경우

  1. `s[idx]`와 `w[idx]`가 대응되지 않는다.

  2. w 끝에 도달했다.

     - 패턴에 `*`이 하나도 없는 경우, 패턴과 문자열의 길이가 정확히 같아야만 패턴과 문자열이 대응된다.

  3. s 끝에 도달했다.

     - 패턴은 남았지만 문자열이 이미 끝난 경우, 남은 패턴이 전부 `*`으로 구성되어 있지 않다면 대응 실패

  4. `w[idx]`가 `*`인 경우

     - `*`가 몇 글자에 대응될 지 모르기 때문에, 0글자부터 남은 문자열의 길이를 순회하며 모든 가능성을 검사한다.

     - 이후 패턴과 문자열으로 재귀호출 했을 때 답이 하나라도 참이면, 참이 된다.
